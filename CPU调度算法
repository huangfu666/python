一、先来先服务调度（First Come First Served，FCFS）
  先来先服务调度是最简单的CPU调度算法，其实现过程容易，可采用 FIFO 队列管理。 该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备队列中选择最先进入该队列的一个或多个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
  在进程调度中，FCFS每次从就绪队列中选择最先进入该队列的线程，将CPU分配给它，使之投入运行，知道完成或因某种原因而阻塞时才释放CPU。采用FCFS策略的平均等待时间通常不是最小的，且如果进程CPU区间时间变化很大，平均等待时间也会变化很大。
  FCFS调度算法是非抢占式的。一旦CPU被分配给了一个进程，该进程会保持CPU直到释放CPU为止，即程序终止或是请求I/O。FCFS算法对于分时系统（每个用户需要定时地得到一定的CPU时间）是特别麻烦的。允许一个进程保持CPU时间过长将是个严重错误。
  FCFS算法的特点市算法简单，但效率低下，对长作业比较有利，但对短作业不利（相比SJF和高响应比），有利于CPU繁忙型作业；而不利于I/O繁忙型作业。


二、最短作业优先调度（Shortest Job First，SJF）
  短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。这一算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）则是从就绪队列中选择一个估计运行时间最短的进程，将CPU分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放CPU。

  这一算法将每个进程与其下一个CPU区间段相关联。当CPU为空闲时，它会赋给具有最短CPU区间的进程。如果两个进程具有相同长度，那么可以使用FCFS调度来处理。一个更为适当的表示是最短下一个CPU区间的算法，这是因为调度检查进程的下一个CPU区间的长度，而不是其总长度。

  SJF算法的平均等待时间、平均周转时间最少。该算法对短作业或短进程最为有利，它可获得最短的平均周转时间。但它忽略等待时间的长短，对长作业不利，特别是在抢占方式下，可能会使长作业无限延迟。对于抢占式 SJF 进程调度，还需要考虑是按最短原则还是按剩余最短原则抢占。 理论上该方法在等待时间方面是最优的，但实际上无法预测下一个 CPU 瞬时段的长度。

  SJF调度算法可证明为最佳的，这是因为对于给定的一组进程，SJF算法的平均等待时间最小。通过将最短进程移到长进程之前，短进程等待时间的减少大于长进程等待时间的增加。因而，平均等待时间减少了。

  SJF算法的真正困难是如何知道下一个CPU区间的长度。对于批处理系统的长期（作业）调度，可以将用户提交作业时所指定的进程时间极限作为长度。SJF调度经常用于长期调度。

  虽然SJF算法最佳，但是它不能在短期CPU调度层次上加以实现。因为没有办法知道下一个CPU区间的长度。一种方法是近似SJF调度。虽然不知道下一个CPU区间的长度，但是可以预测它。认为下一个CPU区间的长度与以前的相似。因此，通过计算下一个CPU区间长度近似值，能选择具有最短预测CPU区间的进程来进行。


三、优先级调度（Highest Privilege First，HPF）
  HPF是让具有高优先级的作业或进程获得优先服务。优先级通常用一个整型的优先数表示。优先级的设置可采用静态的或动态的两种方式。动态设置优先级可使调度更为灵活，使调度性能得到改善。HPF 调度可以是抢占式的或非抢占式的。

  优先级调度可通过内部或外部方式来定义。内部定义优先级使用一些测量数据以计算进程优先级。例如，时间极限，内存要求，打开文件的数量和平均I/O区间与平均CPU区间之比都可以用于计算优先级。外部优先级是通过操作系统之外的准则来定义的，如进程重要性，用于支付使用计算机的费用类型和数量，赞助工作的单位，其他因素。

  优先级调度可以是抢占或者非抢占的。当一个进程到达就绪队列时，其有优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。

  优先级调度算法的一个主要问题是无穷阻塞（indefinite blocking）或饥饿(starvation)。

  可以运行但缺乏CPU的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。通常，会发生两种情况，要么进程最终能运行，在系统最后为轻负荷时，要么系统最终崩溃并失去所有未完成的低优先级进程。
低优先级进程无穷等待问题的解决之一是老化（aging）。老化是一种技术，以逐渐增加在系统中等待很长世间的进程的优先级。
